Link - https://asciinema.org/a/BqdmUa6hpbRcnqepBZE38ycTK

Ejercicio 1
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 1
//Convertir temperatura de Celsius a Fahrenheit
//Conversión de unidades, I/O
//Dispositivos de monitoreo ambiental
///////////////////////////////////////////////

//C#

//ARM64
.section .data
prompt: .asciz "Introduce la temperatura en Celsius: "
result_msg: .asciz "La temperatura en Fahrenheit es: %.2f\n"
scanf_format: .asciz "%lf"  // Formato para leer double

temp_celsius: .double 0
temp_fahrenheit: .double 0

// Definición de constantes
nine: .double 9.0
five: .double 5.0
thirtytwo: .double 32.0

.section .text
.global main

main:
    // Pedir la temperatura en Celsius
    ldr x0, =prompt
    bl printf

    // Leer la temperatura en Celsius
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =temp_celsius // Cargar dirección de temp_celsius
    bl scanf

    // Convertir Celsius a Fahrenheit
    ldr x1, =temp_celsius  // Cargar dirección de temp_celsius
    ldr d0, [x1]           // Cargar el valor de Celsius en d0

    // Cargar los valores constantes desde la sección de datos
    ldr x1, =nine          // Cargar dirección de 9.0
    ldr d2, [x1]           // Cargar 9.0 en d2
    ldr x1, =five          // Cargar dirección de 5.0
    ldr d3, [x1]           // Cargar 5.0 en d3
    ldr x1, =thirtytwo     // Cargar dirección de 32.0
    ldr d4, [x1]           // Cargar 32.0 en d4

    // Realizar la conversión: (C * 9/5) + 32
    fmul d1, d0, d2        // d1 = Celsius * 9.0
    fdiv d1, d1, d3        // d1 = (Celsius * 9.0) / 5.0
    fadd d1, d1, d4        // d1 = ((Celsius * 9.0) / 5.0) + 32.0

    // Almacenar el resultado en temp_fahrenheit
    ldr x1, =temp_fahrenheit // Cargar dirección de temp_fahrenheit
    str d1, [x1]             // Almacenar el resultado

    // Mostrar el resultado
    ldr x0, =result_msg      // Cargar dirección del mensaje
    ldr x1, =temp_fahrenheit  // Cargar dirección de temp_fahrenheit
    ldr d0, [x1]             // Cargar el resultado en d0
    bl printf

    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0


***********************************************************************************************************

Ejercicio 2
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 2
//Suma de dos números	
//Aritmética básica	
///////////////////////////////////////////////
//C#

//ARM64
.section .data
prompt1: .asciz "Introduce el primer número: "
prompt2: .asciz "Introduce el segundo número: "
result_msg: .asciz "La suma es: %ld\n"
scanf_format: .asciz "%ld"  // Formato para leer long int

num1: .quad 0
num2: .quad 0
result: .quad 0

.section .text
.global main

main:
    // Pedir el primer número
    ldr x0, =prompt1
    bl printf

    // Leer el primer número
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =num1        // Cargar dirección de num1
    bl scanf

    // Pedir el segundo número
    ldr x0, =prompt2
    bl printf

    // Leer el segundo número
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =num2        // Cargar dirección de num2
    bl scanf

    // Sumar los números
    ldr x1, =num1
    ldr x1, [x1]         // Cargar el primer número
    ldr x2, =num2
    ldr x2, [x2]         // Cargar el segundo número
    add x3, x1, x2       // Sumar los números
    ldr x0, =result
    str x3, [x0]         // Almacenar el resultado

    // Mostrar el resultado
    ldr x0, =result_msg
    ldr x1, =result
    ldr x1, [x1]         // Cargar el resultado
    bl printf

    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0


2–Compila el archivo de ensamblador:
as -o suma.o suma.s
gcc -o suma suma.o
./suma

****************************************************************************************

Ejercicio 3
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 3
//Resta de dos números	
//Aritmética básica	
///////////////////////////////////////////////

//C#

//ARM64
.section .data
prompt1: .asciz "Introduce el primer número: "
prompt2: .asciz "Introduce el segundo número: "
result_msg: .asciz "La resta es: %ld\n"
scanf_format: .asciz "%ld"  // Formato para leer long int

num1: .quad 0
num2: .quad 0
result: .quad 0

.section .text
.global main

main:
    // Pedir el primer número
    ldr x0, =prompt1
    bl printf

    // Leer el primer número
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =num1        // Cargar dirección de num1
    bl scanf

    // Pedir el segundo número
    ldr x0, =prompt2
    bl printf

    // Leer el segundo número
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =num2        // Cargar dirección de num2
    bl scanf

    // Restar los números
    ldr x1, =num1
    ldr x1, [x1]         // Cargar el primer número
    ldr x2, =num2
    ldr x2, [x2]         // Cargar el segundo número
    sub x3, x1, x2       // Restar los números
    ldr x0, =result
    str x3, [x0]         // Almacenar el resultado

    // Mostrar el resultado
    ldr x0, =result_msg
    ldr x1, =result
    ldr x1, [x1]         // Cargar el resultado
    bl printf

    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0


*******************************************************************************************

Ejercicio 4
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 4
//Multiplicación de dos números	
//Aritmética básica (MUL)	
///////////////////////////////////////////////

//C#

//ARM64
.section .data
prompt1: .asciz "Introduce el primer número: "
prompt2: .asciz "Introduce el segundo número: "
result_msg: .asciz "La multiplicación es: %ld\n"
scanf_format: .asciz "%ld"  // Formato para leer long int

num1: .quad 0
num2: .quad 0
result: .quad 0

.section .text
.global main

main:
    // Pedir el primer número
    ldr x0, =prompt1
    bl printf

    // Leer el primer número
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =num1        // Cargar dirección de num1
    bl scanf

    // Pedir el segundo número
    ldr x0, =prompt2
    bl printf

    // Leer el segundo número
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =num2        // Cargar dirección de num2
    bl scanf

    // Multiplicar los números
    ldr x1, =num1
    ldr x1, [x1]         // Cargar el primer número
    ldr x2, =num2
    ldr x2, [x2]         // Cargar el segundo número
    mul x3, x1, x2       // Multiplicar los números
    ldr x0, =result
    str x3, [x0]         // Almacenar el resultado

    // Mostrar el resultado
    ldr x0, =result_msg
    ldr x1, =result
    ldr x1, [x1]         // Cargar el resultado
    bl printf

    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0


*************************************************************************

Ejercicio 5
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 5
//División de dos números	
//Aritmética (UDIV, SDIV)	
///////////////////////////////////////////////

//C#

//ARM64
.section .data
prompt1: .asciz "Introduce el primer número: "
prompt2: .asciz "Introduce el segundo número: "
result_msg: .asciz "La división es: %ld\n"
scanf_format: .asciz "%ld"  // Formato para leer long int

num1: .quad 0
num2: .quad 0
result: .quad 0

.section .text
.global main

main:
    // Pedir el primer número
    ldr x0, =prompt1
    bl printf

    // Leer el primer número
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =num1        // Cargar dirección de num1
    bl scanf

    // Pedir el segundo número
    ldr x0, =prompt2
    bl printf

    // Leer el segundo número
    ldr x0, =scanf_format // Cargar formato de scanf
    ldr x1, =num2        // Cargar dirección de num2
    bl scanf

    // Dividir los números
    ldr x1, =num1
    ldr x1, [x1]         // Cargar el primer número
    ldr x2, =num2
    ldr x2, [x2]         // Cargar el segundo número

    // Comprobar si el segundo número es cero
    cmp x2, #0
    beq division_por_cero // Saltar si el segundo número es cero

    sdiv x3, x1, x2       // Dividir los números
    ldr x0, =result
    str x3, [x0]         // Almacenar el resultado

    // Mostrar el resultado
    ldr x0, =result_msg
    ldr x1, =result
    ldr x1, [x1]         // Cargar el resultado
    bl printf

    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0

division_por_cero:
    ldr x0, =prompt1
    ldr x0, =prompt2
    ldr x1, =num2
    // Mostrar un mensaje de error si se intenta dividir por cero
    ldr x0, =prompt1
    ldr x1, =prompt2
    ldr x2, =num1
    // Aquí puedes colocar un mensaje que indique que la división por cero no es permitida.
    ldr x0, =prompt1
    ldr x0, =prompt2
    ldr x0, =num2
    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0

***********************************************************************************
Ejercicio 6
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 6
//Suma de los N primeros números naturales	
//Bucles y contadores	
///////////////////////////////////////////////

//C#

//ARM64
.section .data
prompt: .asciz "Introduce un número N para calcular la suma de los primeros N números naturales: "
result_msg: .asciz "La suma de los primeros %ld números naturales es %ld.\n"
scanf_format: .asciz "%ld"

number: .quad 0
sum: .quad 0

.section .text
.global main

main:
    // Pedir al usuario un número
    ldr x0, =prompt
    bl printf

    // Leer el número
    ldr x0, =scanf_format
    ldr x1, =number
    bl scanf

    // Cargar el número en x1
    ldr x1, =number
    ldr x1, [x1]

    // Inicializar la suma en 0
    mov x2, #0

    // Calcular la suma de los primeros N números naturales
    mov x3, #1        // Inicializar contador en 1
sum_loop:
    cmp x3, x1        // Comparar contador con N
    bgt end_sum       // Si contador > N, salir del bucle

    add x2, x2, x3    // suma += contador
    add x3, x3, #1    // Incrementar contador
    b sum_loop        // Volver al inicio del bucle

end_sum:
    // Guardar el resultado de la suma
    ldr x4, =sum
    str x2, [x4]

    // Imprimir el resultado
    ldr x0, =result_msg
    mov x1, x1        // cargar N
    ldr x2, =sum
    ldr x2, [x2]      // cargar el resultado
    bl printf

    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0



as -o suma_naturales.o suma_naturales.s
gcc -o suma_naturales suma_naturales.o
./suma_naturales


************************************************************************************************

ejercicio7  
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 7
//Factorial de un número	
//Recursión/bucles	
///////////////////////////////////////////////

//C#

//ARM64
.section .data
prompt: .asciz "Introduce un número para calcular su factorial: "
result_msg: .asciz "El factorial de %ld es %ld.\n"
scanf_format: .asciz "%ld"

number: .quad 0
factorial: .quad 1

.section .text
.global main

main:
    // Pedir al usuario un número
    ldr x0, =prompt
    bl printf

    // Leer el número
    ldr x0, =scanf_format
    ldr x1, =number
    bl scanf

    // Cargar el número en x1
    ldr x1, =number
    ldr x1, [x1]

    // Inicializar factorial en 1
    mov x2, #1

    // Calcular el factorial
    mov x3, #1        // Inicializar contador en 1
factorial_loop:
    cmp x3, x1        // Comparar contador con el número
    bgt end_factorial // Si contador > número, salir del bucle

    mul x2, x2, x3    // factorial *= contador
    add x3, x3, #1    // Incrementar contador
    b factorial_loop   // Volver al inicio del bucle

end_factorial:
    // Guardar el resultado del factorial
    ldr x4, =factorial
    str x2, [x4]

    // Imprimir el resultado
    ldr x0, =result_msg
    mov x1, x1        // cargar el número
    ldr x2, =factorial
    ldr x2, [x2]      // cargar el resultado
    bl printf

    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0


********************************************************

ejercicio 8 
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 8
//Serie de Fibonacci	
//Bucles y manejo de memoria	
///////////////////////////////////////////////

//C#

//ARM64
.section .data
prompt: .asciz "Introduce el número de términos de la serie de Fibonacci: "
result_msg: .asciz "Fibonacci[%ld] = %ld\n"
scanf_format: .asciz "%ld"

n_terms: .quad 0
fib1: .quad 0
fib2: .quad 1

.section .text
.global main

main:
    // Pedir el número de términos
    ldr x0, =prompt
    bl printf

    // Leer el número de términos
    ldr x0, =scanf_format
    ldr x1, =n_terms
    bl scanf

    // Cargar el número de términos en x1
    ldr x1, =n_terms
    ldr x1, [x1]

    // Verificar si n es menor o igual a 0
    cmp x1, #0
    ble end_program      // Si n <= 0, salir

    // Inicializar los primeros dos términos de Fibonacci
    ldr x4, =fib1
    ldr x5, =fib2
    mov x0, #0           // Primer término (0)
    str x0, [x4]         // fib1 = 0

    mov x0, #1           // Segundo término (1)
    str x0, [x5]         // fib2 = 1

    // Imprimir el primer término
    ldr x0, =result_msg
    mov x1, #0           // Índice 0
    ldr x2, [x4]         // Cargar fib1 (0)
    bl printf

    // Si solo se quiere imprimir el primer término, salir
    cmp x1, #1
    beq end_program

    // Imprimir el segundo término
    mov x1, #1           // Índice 1
    ldr x0, =result_msg
    ldr x2, [x5]         // Cargar fib2 (1)
    bl printf

    // Calcular y mostrar el resto de los términos
    mov x7, #2           // Contador de términos ya impresos

fibonacci_loop:
    // Cargar los dos últimos términos
    ldr x10, [x4]        // fib1
    ldr x11, [x5]        // fib2
    add x12, x10, x11    // x12 = fib1 + fib2

    // Imprimir el término actual
    ldr x0, =result_msg
    mov x1, x7           // Índice actual
    mov x2, x12          // Valor a imprimir
    bl printf

    // Actualizar los términos
    str x11, [x4]        // fib1 = fib2
    str x12, [x5]        // fib2 = nuevo término (x12)

    // Incrementar el contador
    add x7, x7, #1
    cmp x7, x1
    blt fibonacci_loop

end_program:
    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0

********************************************************************

ejercicio 9 
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 9
//Verificar si un número es primo	
//Saltos condicionales	
///////////////////////////////////////////////

//C#

//ARM64
.section .data
prompt: .asciz "Introduce un número: "
result_msg: .asciz "El número %ld es primo.\n"
not_prime_msg: .asciz "El número %ld no es primo.\n"
scanf_format: .asciz "%ld"

num: .quad 0

.section .text
.global main

main:
    // Pedir un número
    ldr x0, =prompt
    bl printf

    // Leer el número
    ldr x0, =scanf_format
    ldr x1, =num
    bl scanf

    // Cargar el número en x1
    ldr x1, =num
    ldr x1, [x1]

    // Comprobar si el número es menor que 2
    cmp x1, #2
    blt not_prime      // Si num < 2, no es primo

    // Comenzar a verificar divisores
    mov x2, #2         // x2 será el divisor
    mov x3, x1         // Guardamos el número original en x3

check_loop:
    // Calcular x2 * x2
    mul x4, x2, x2
    cmp x4, x3
    bgt is_prime       // Si x2 * x2 > num, es primo

    // Verificar si num es divisible por x2
    mov x0, x3        // Mover num a x0
    sdiv x5, x0, x2   // x5 = num / x2
    mul x6, x5, x2    // x6 = x5 * x2
    cmp x6, x3        // Comparar x6 con num
    beq not_prime      // Si son iguales, no es primo

    // Incrementar divisor
    add x2, x2, #1
    b check_loop

is_prime:
    // Imprimir que es primo
    ldr x0, =result_msg
    ldr x1, =num
    ldr x1, [x1]      // Cargar el número
    bl printf
    b end_program

not_prime:
    // Imprimir que no es primo
    ldr x0, =not_prime_msg
    ldr x1, =num
    ldr x1, [x1]      // Cargar el número
    bl printf

end_program:
    // Salir del programa
    mov x0, #0
    mov x8, #93
    svc 0

*************************************************************

ejercicio 10 
////////////////////////////////////////////////
//Angel Fernando Garcia Calderon
//No.control - 22210306
//Hora- 4 a 5
//Lenguajes de interfaz
//Ejercicio 10
//Invertir una cadena	
//Manipulación de cadenas	
///////////////////////////////////////////////

//C#

//ARM64
.section .data
    mensaje: .asciz "Ingresa una cadena para invertir: "
    resultado: .asciz "\nCadena invertida: "

.section .bss
    .lcomm buffer, 100       // Buffer para la cadena de entrada, tamaño 100 bytes

.section .text
.global _start

_start:
    // Imprimir mensaje para ingresar cadena
    mov x0, 1                 // file descriptor 1 (stdout)
    ldr x1, =mensaje          // Dirección del mensaje
    mov x2, 32                // Longitud del mensaje
    mov x8, 64                // syscall write
    svc 0

    // Leer cadena del usuario
    mov x0, 0                 // file descriptor 0 (stdin)
    ldr x1, =buffer           // Dirección del buffer
    mov x2, 100               // Tamaño máximo de la entrada
    mov x8, 63                // syscall read
    svc 0

    // Calcular la longitud de la cadena ingresada
    ldr x3, =buffer           // Dirección del buffer
    mov x4, #0                // Inicializamos el contador de longitud
contar_longitud:
    ldrb w5, [x3, x4]         // Leer byte
    cmp w5, #0                // Verificar si es fin de cadena ('\0')
    beq fin_contar
    add x4, x4, #1            // Incrementar longitud
    b contar_longitud

fin_contar:

    // Remover el salto de línea al final de la entrada
    cmp x4, #0                // Si la longitud es 0, saltar
    beq invertir
    sub x4, x4, #1            // Ajustar la longitud
    ldrb w5, [x3, x4]
    cmp w5, #10               // Si es '\n', reemplazar con '\0'
    bne invertir
    strb w0, [x3, x4]         // Reemplazar '\n' por '\0'

invertir:
    // Punteros para inicio y fin de la cadena
    ldr x1, =buffer           // x1 apunta al inicio de la cadena
    add x2, x1, x4            // x2 apunta al final de la cadena
    sub x2, x2, #1            // Ajustar para no incluir '\0'

invertir_loop:
    cmp x1, x2                // Comparar punteros de inicio y fin
    bge imprimir_resultado    // Si se cruzan, terminar inversión

    // Intercambiar caracteres en x1 y x2
    ldrb w3, [x1]             // Cargar carácter en inicio (x1)
    ldrb w4, [x2]             // Cargar carácter en fin (x2)
    strb w4, [x1]             // Escribir carácter de fin en inicio
    strb w3, [x2]             // Escribir carácter de inicio en fin

    // Mover punteros hacia el centro
    add x1, x1, #1            // Avanzar puntero de inicio
    sub x2, x2, #1            // Retroceder puntero de fin
    b invertir_loop

imprimir_resultado:
    // Imprimir mensaje de resultado
    mov x0, 1                 // file descriptor 1 (stdout)
    ldr x1, =resultado        // Dirección del mensaje de resultado
    mov x2, 18                // Longitud del mensaje
    mov x8, 64                // syscall write
    svc 0

    // Imprimir cadena invertida
    mov x0, 1                 // file descriptor 1 (stdout)
    ldr x1, =buffer           // Dirección del buffer (cadena invertida)
    mov x2, x4                // Longitud de la cadena invertida
    mov x8, 64                // syscall write
    svc 0

    // Terminar programa
    mov x8, 93                // syscall exit
    mov x0, 0                 // Código de salida
    svc 0

*****************************************************************************
